# Dataflow Architecture

Helios2400 uses a entity-component-system architecture, with significant use of a message bus.

![Architecture](https://github.com/Sewerbird/Helios2400/blob/master/docs/game_architecture.png)

## Registry

The Registry is concerned with the actual 'data' of a game: the stuff you would store in a database of values. This includes things like what art asset a terrain tile uses, the attack rating of an army, the health of a unit, the position of a planet, and so on. Helios2400 utilizes entities (GameObjects) made up of components to organize the data:

- **Datatypes** are the smallest organizational unit, and include things like arrays of numbers, polygons, coordinate tuples, and other raw data
- **Components** are made up of datatypes, and are the principal objects of manipulation used by game systems. Components group datatypes together towards asemantic purpose: a 'Renderable' component, for example, groups a picture dataype and a position datatype to enable drawing a picture to screen.
- **Game Objects** are simply a bundle of components all associated to the same unique identifier (UID). Game Objects represent semantic elements in the game, such as a clickable unit or a button in the UI

All game data lives in components stored in the **Registry**, which is a dictionary of Game Objects referenced by their UID. The Registry can be thought of as a 2-d matrix of components, with components in the same column being members of the same game object, and components in the same row being members of the same 'component pool'.

## Systems

Helios2400 has several systems, each responsible for a subset of the Registry. Systems are the 'functions' of the game, and typically are called once every tick/frame of the game. Systems have an anatomy of their own:

- Each system has one or more **Structures**, which define both *which* components/GameObjects in the registry the system operates on and *how* they are related to each other. In some systems this is a simple list, but other systems might maintain a map or a scenegraph built up of UIDs
- Systems have **External Functions**, which basically just tell the system to perform its task. This might be a `draw`, `update`, or some similar on-demand function.
- Systems each have **Specified Pools**. Systems state what components an object must have in order for the structure to be able to operate on the game object.

**It is important to REFRAIN FROM STORING PERSISTENT DATA IN SYSTEM STRUCTURES**. Although a cache within the system is acceptable if needed, systems should try to restrict themselves as much as possible to only storing references to objects in the Registry, rather than copy them. Conceptually, a system should be able (in principle) to be generated every frame of the game, at least in its design. This is to discourage keeping game state outside of the registry (which would complicate determinism of the game engine).

## Mutator Bus

Modifications originating from outside the Registry may only come from those resulting from the application of **Mutators**, a kind of object that defines an applicable and reversible state modification. Mutators are generated by Systems, and then added to the Mutator Bus in a queue. At specific times, the Bus will then apply all mutators in its Queue (FIFO) to the Registry. Each mutator applied in this way:

1. Is checked that its parameters are valid by calling its `validate()` function. This includes checks that the mutator's target exists, certain game rules checked, etc
2. The mutator's `apply()` function is applied to the Registry, resulting in state changes
3. The mutator object is then pushed onto the Bus' History stack
4. At some point in the future, the mutator may be popped off the History stack
5. If this occurs, the mutator's `rollback()` function is applied to the Registry, undoing its changes
6. Finally, a `rollback`ed mutator is placed at the head of the Queue.

## Message Bus

The Message Bus is actually a part of the implementation details of the Registry, but it's important to introduce here. The matrix of components that make up the Registry has the feature of being able to act in a way similar to a spreadsheet: a change to a component's data can trigger another component's data to change according to a formula. This is accomplished by a component `subscribe()`-ing to the Message Bus with a callback function and a component it is interested in. When a component `publish()`-es a message to the Message Bus (as a result of a mutator, or as a result of a subscription callback), the Message Bus informs the subscribers interested in that component about the published message, which then serves as the argument for their callback functions. Components can then alter/refresh their data, and potentially fire off another `publish` event.

The Message bus also notifies Systems if their structures' referenced GameObjects have been changed (structures are `subscribe()`-ed to their UID references)
